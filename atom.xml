<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>magic station</title>
  
  
  <link href="https://www.magicat.cc/atom.xml" rel="self"/>
  
  <link href="https://www.magicat.cc/"/>
  <updated>2025-05-15T15:48:04.000Z</updated>
  <id>https://www.magicat.cc/</id>
  
  <author>
    <name>MagicCat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>两数之和</title>
    <link href="https://www.magicat.cc/posts/leetcode-two-sum.html"/>
    <id>https://www.magicat.cc/posts/leetcode-two-sum.html</id>
    <published>2025-05-15T15:48:04.000Z</published>
    <updated>2025-05-15T15:48:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-a.markji.com/files/68260d18fae6898c0c782ddb_hd.png?e=1747326777192&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:bB8UnaqcvzESiOPfxSYyLCzCv1s=" alt=""></p><h2 id="解法一：暴力枚举">解法一：暴力枚举</h2><p>复杂度n^2，对每个执行枚举。</p><h2 id="解法二：排序双指针">解法二：排序双指针</h2><p>复杂度nlogn，排好序之后用结构体保存初始下标，后从首尾往中间遍历即可。</p><h2 id="解法三：哈希表">解法三：哈希表</h2><p>复杂度n，key是值，value是index，遍历的过程中查找是否存在对应的target-x，没找到就把他加入然后继续找。<br><img src="https://cdn-a.markji.com/files/68260d24fae6898c0c782eaa_hd.png?e=1747326788512&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cW1cbQQwquvKtvVUPNrIz0vxIEQ=" alt=""></p>]]></content>
    
    
    <summary type="html">LeetCode Hot100 两数之和的三种解法详解</summary>
    
    
    
    <category term="算法题解" scheme="https://www.magicat.cc/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法" scheme="https://www.magicat.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.magicat.cc/tags/LeetCode/"/>
    
    <category term="哈希表" scheme="https://www.magicat.cc/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>区块链流程图3 交易系统实现</title>
    <link href="https://www.magicat.cc/posts/blockchain-transaction-system.html"/>
    <id>https://www.magicat.cc/posts/blockchain-transaction-system.html</id>
    <published>2025-05-01T13:12:37.000Z</published>
    <updated>2025-05-01T13:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交易结构设计">交易结构设计</h2><h3 id="TXInput结构">TXInput结构</h3><ul><li>引用的输出索引(在vec中的位置)</li><li>解锁脚本（这里简化为自身公钥）</li><li>如果我的地址和输出索引的锁定脚本一样，证明我可以用这笔钱</li></ul><h3 id="TXOutput结构">TXOutput结构</h3><ul><li>每个output索引为vec中的位置</li><li>币的数量</li><li>锁定脚本（发送方公钥）</li><li>表示谁有资格使用这笔钱(我发给谁了)</li><li><img src="https://cdn-a.markji.com/files/68137352e895986c474ac32e_hd.png?e=1746107762858&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:lULgq0qdO5GNjMfcBF0HfbbVt70=" alt=""></li></ul><h3 id="Transaction结构">Transaction结构</h3><p>成员：</p><ul><li>Vec<TXOutput></li><li>Vec<TXInput></li><li>id</li></ul><p>方法：</p><h4 id="new-UTXO">new_UTXO</h4><ul><li>find_spendable_outputs(blockchain函数)</li><li>找到需要使用的vec<input>证明我可以使用这些钱</li><li>把全部的utxo都拿出来了，拼成input(证实自己有动用这笔钱权力)</li><li>把全部余额合并成一个output，发出去</li><li>计算要找回多少钱，发一份给自身</li><li>最后把vin和vout拼接成Transaction返回’</li><li><img src="https://cdn-a.markji.com/files/6813735ce895986c474ad1db_hd.png?e=1746107772788&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:NHHW1KSbXeX45LTwMGNLFscJViY=" alt=""></li></ul><h4 id="new-coinbase">new_coinbase</h4><ul><li>直接生成一个tx</li><li>input里的解锁脚本和out索引都没有，因为不需要证明就可以用(新块)</li><li>拼接output然后返回tx</li></ul><h4 id="is-coinbase">is_coinbase</h4><ul><li>就判断当前tx是否只有一个input啥的就行</li></ul><h2 id="Block结构修改">Block结构修改</h2><h3 id="数据结构">数据结构</h3><ul><li>把data字段换成了Vec<Transaction></li></ul><h3 id="方法实现">方法实现</h3><h4 id="prepare-hash-data">prepare_hash_data</h4><ul><li>把待哈希内容序列化</li><li>注：由于时间戳一开始就被计算出来，故并不是挖矿成功的时间戳</li></ul><h4 id="validate">validate</h4><ul><li>调用prepare获取数据</li><li>注：每次要重新调用prepare是因为nonce每次都变化了</li><li>判断是否哈希值符合要求</li></ul><h4 id="run-proof-of-work">run_proof_of_work</h4><ul><li>循环调用validata</li><li>每次把nonce+1，成功了则把self.hash赋值</li></ul><h4 id="new-block">new_block</h4><ul><li>获取当前时间戳</li><li>新创建block，赋值好前哈希，Vec<Transaction>，时间戳</li><li>调用run_proof赋值哈希</li></ul><h4 id="new-genesis-block">new_genesis_block</h4><ul><li>直接生成</li></ul><h2 id="Blockchain结构优化">Blockchain结构优化</h2><h3 id="成员变量">成员变量</h3><ul><li>继续删除currentHash，转移到迭代器里面</li><li>tip最新区块的哈希值</li><li>db</li></ul><h3 id="方法实现-2">方法实现</h3><h4 id="new-构造函数">new()构造函数</h4><ul><li>返回blockchain</li><li>打开db</li><li>调用get(“last”)查询<ul><li>last为存储的最后一个哈希值</li><li>若不存在：?表示式报错返回</li><li>若存在：把tip和db都赋值后返回</li></ul></li></ul><h4 id="create-blockchain">create_blockchain</h4><ul><li>调用生成创世交易函数</li><li>把tx传入生成创世块函数，生成创世块</li><li>把创世块信息等insert进数据库</li></ul><h4 id="find-spendable-outputs">find_spendable_outputs</h4><ul><li>在区块链中查找发送者可用的未花费输出</li><li>返回元组(总金额, 可用输出的map)</li></ul><h4 id="find-UTXO">find_UTXO</h4><ul><li>把find_unspent_transactions的返回的tx提纯</li><li>直接返回UTXO</li></ul><h4 id="find-unspent-transactions">find_unspent_transactions</h4><ul><li>获取包含自身地址的所有未花费的输出</li><li>从新往旧遍历区块链</li><li>先把vout判断是否被vin引用了</li><li>再把当前块的vin引用的vout注册进哈希</li></ul><h4 id="find-spendable-outputs-2">find_spendable_outputs</h4><ul><li>查找可用于支付指定金额的输出</li><li>调用find_unspent</li><li>遍历所有的tx中的output，然后不断加accumulated</li><li>够了就返回积累值和对应的output</li></ul><h4 id="mine-block（原add-block）">mine_block（原add_block）</h4><ul><li>从last获取新块的前哈希</li><li>调用new_block(data, prev.get_hash())</li><li>每个块都是一个键值对存储key为hash，value是块的序列化</li><li>插入db，并更新last和tip和curretHash</li></ul><h4 id="Iterator">Iterator</h4><ul><li>next<ul><li>调用currentHash来get块</li><li>返回这个块，并且把curretHash赋值为前hash</li></ul></li></ul><h2 id="CLI改进">CLI改进</h2><h3 id="结构修改">结构修改</h3><ul><li>删除了blockchain成员</li></ul><h3 id="命令实现">命令实现</h3><p>run：</p><ul><li>注册命令行app</li><li>判断是否输入了对应命令<ul><li>删除了addblock/换成send</li><li>执行print_chain</li><li>getbalance：调用find_UTXO之后遍历相加</li><li>createblockchain：调用create_blockchain</li><li>send：<ul><li>解析from,to,amount</li><li>调用new_UTXO生成交易信息</li><li>调用mine_block生成区块</li></ul></li></ul></li></ul><h2 id="主程序实现">主程序实现</h2><p><a href="http://main.rs">main.rs</a>：</p><ul><li>初始化日志系统</li><li>创建cli</li><li>调用run</li></ul>]]></content>
    
    
    <summary type="html">Rust实现区块链交易系统的详细设计与实现流程</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Rust" scheme="https://www.magicat.cc/tags/Rust/"/>
    
    <category term="交易系统" scheme="https://www.magicat.cc/tags/%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>区块链流程图2 命令行实现</title>
    <link href="https://www.magicat.cc/posts/blockchain-cli.html"/>
    <id>https://www.magicat.cc/posts/blockchain-cli.html</id>
    <published>2025-05-01T13:10:37.000Z</published>
    <updated>2025-05-01T13:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Block结构实现">Block结构实现</h2><h3 id="数据准备">数据准备</h3><p>prepare_hash_data：</p><ul><li>把待哈希内容序列化</li><li>注：由于时间戳一开始就被计算出来，故并不是挖矿成功的时间戳</li></ul><h3 id="验证机制">验证机制</h3><p>validate：</p><ul><li>调用prepare获取数据</li><li>注：每次要重新调用prepare是因为nonce每次都变化了</li><li>判断是否哈希值符合要求</li></ul><h3 id="工作量证明执行">工作量证明执行</h3><p>run_proof_of_work：</p><ul><li>循环调用validata</li><li>每次把nonce+1，成功了则把self.hash赋值</li></ul><h3 id="区块创建">区块创建</h3><p>new_block：</p><ul><li>获取当前时间戳</li><li>新创建block，赋值好前哈希，data，时间戳</li><li>调用run_proof赋值哈希</li></ul><h3 id="创世块生成">创世块生成</h3><p>new_genesis_block：</p><ul><li>直接生成</li></ul><h2 id="Blockchain结构实现">Blockchain结构实现</h2><h3 id="成员变量">成员变量</h3><ul><li>删除blockchains</li><li>tip最新区块的哈希值</li><li>db</li><li>currentHash（用于迭代器）当前哈希</li><li>从尾到头部返回</li></ul><h3 id="构造函数">构造函数</h3><p>new()：</p><ul><li>返回blockchain</li><li>打开db</li><li>调用get(“last”)查询<ul><li>last为存储的最后一个哈希值</li><li>若不存在<ul><li>创建创世块并insert</li><li>为last字段也insert赋值</li><li>初始化blockchain并flush返回</li></ul></li><li>若存在<ul><li>把tip和currentHash都赋值为这个哈希</li><li>赋值db之后返回</li></ul></li></ul></li></ul><h3 id="区块添加">区块添加</h3><p>add_block：</p><ul><li>从last获取新块的前哈希</li><li>调用new_block(data, prev.get_hash())</li><li>每个块都是一个键值对存储key为hash，value是块的序列化</li><li>插入db，并更新last和tip和curretHash</li></ul><h3 id="迭代器实现">迭代器实现</h3><p>Iterator：</p><ul><li>next<ul><li>调用currentHash来get块</li><li>返回这个块，并且把curretHash赋值为前hash</li></ul></li></ul><h2 id="CLI实现">CLI实现</h2><h3 id="结构定义">结构定义</h3><ul><li>就一个blockchain成员</li></ul><h3 id="初始化">初始化</h3><p>new：</p><ul><li>调用blockchain构造函数</li></ul><h3 id="命令行运行">命令行运行</h3><p>run：</p><ul><li>注册命令行app</li><li>判断是否输入了对应命令<ul><li>执行addblock</li><li>执行print_chain</li></ul></li></ul><h2 id="主程序实现">主程序实现</h2><p><a href="http://main.rs">main.rs</a>：</p><ul><li>初始化日志系统</li><li>创建cli</li><li>调用run</li></ul>]]></content>
    
    
    <summary type="html">Rust实现区块链命令行接口及数据持久化的详细流程</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Rust" scheme="https://www.magicat.cc/tags/Rust/"/>
    
    <category term="CLI" scheme="https://www.magicat.cc/tags/CLI/"/>
    
  </entry>
  
  <entry>
    <title>区块链流程图1 工作量证明</title>
    <link href="https://www.magicat.cc/posts/blockchain-pow.html"/>
    <id>https://www.magicat.cc/posts/blockchain-pow.html</id>
    <published>2025-05-01T13:04:37.000Z</published>
    <updated>2025-05-01T13:04:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Block结构实现">Block结构实现</h2><h3 id="数据准备">数据准备</h3><p>prepare_hash_data：</p><ul><li>把待哈希内容序列化</li><li>注：由于时间戳一开始就被计算出来，故并不是挖矿成功的时间戳</li></ul><h3 id="验证机制">验证机制</h3><p>validate：</p><ul><li>没检查溢出情况</li><li>调用prepare获取数据</li><li>注：每次要重新调用prepare是因为nonce每次都变化了</li><li>判断是否哈希值符合要求</li></ul><h3 id="工作量证明执行">工作量证明执行</h3><p>run_proof_of_work：</p><ul><li>循环调用validata</li><li>每次把nonce+1，成功了则把self.hash赋值</li></ul><h3 id="区块创建">区块创建</h3><p>new_block：</p><ul><li>获取当前时间戳</li><li>新创建block，赋值好前哈希，data，时间戳</li><li>调用run_proof赋值哈希</li></ul><h3 id="创世块生成">创世块生成</h3><p>new_genesis_block：</p><ul><li>直接生成</li></ul><h2 id="Blockchain结构实现">Blockchain结构实现</h2><h3 id="初始化">初始化</h3><p>new()：</p><ul><li>调用生成创世块</li></ul><h3 id="区块添加">区块添加</h3><p>add_block：</p><ul><li>从vec尾部获取新块的前哈希</li><li>调用new_block(data, prev.get_hash())</li></ul><h2 id="主程序实现">主程序实现</h2><p><a href="http://main.rs">main.rs</a>：</p><ul><li>创建区块链Blockchain::new()</li><li>调用add_block然后传入data</li><li>bc.add_block(String::from(“Send 1 BTC to Ivan”))</li></ul><p>注意：没检查溢出情况</p>]]></content>
    
    
    <summary type="html">Rust实现区块链工作量证明机制的详细流程</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Rust" scheme="https://www.magicat.cc/tags/Rust/"/>
    
    <category term="工作量证明" scheme="https://www.magicat.cc/tags/%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>区块链网络通信流程</title>
    <link href="https://www.magicat.cc/posts/blockchain-network-communication.html"/>
    <id>https://www.magicat.cc/posts/blockchain-network-communication.html</id>
    <published>2025-05-01T13:03:27.000Z</published>
    <updated>2025-05-01T13:03:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接收方处理流程">接收方处理流程</h2><h3 id="服务启动">服务启动</h3><p>调用startserver</p><h3 id="Version消息处理">Version消息处理</h3><p>处理handleVersion：</p><ul><li>若自身慢了，则请求获取块</li><li>若自身快了，则发version给对方</li><li>注：发送version是用来请求同步的</li></ul><h3 id="Inv消息处理">Inv消息处理</h3><p>处理handleInv：</p><ul><li>inv只是一个清单，表示自己有什么块和tx</li><li>收到发送方的inv之后自己判断哪些是要下载的</li><li>然后调用getData执行下载</li></ul><h3 id="Block消息处理">Block消息处理</h3><p>处理handleBlock：</p><ul><li>把新增的区块加到自身链里</li></ul><h3 id="交易处理">交易处理</h3><p>处理handleTx</p><h2 id="发送方处理流程">发送方处理流程</h2><h3 id="服务启动-2">服务启动</h3><p>调用startserver</p><h3 id="区块请求处理">区块请求处理</h3><p>处理handleGetBlock</p><h3 id="数据请求处理">数据请求处理</h3><p>处理getData</p>]]></content>
    
    
    <summary type="html">区块链网络中节点间通信的详细流程及处理机制</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="P2P网络" scheme="https://www.magicat.cc/tags/P2P%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络通信" scheme="https://www.magicat.cc/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>区块链网络架构</title>
    <link href="https://www.magicat.cc/posts/blockchain-network.html"/>
    <id>https://www.magicat.cc/posts/blockchain-network.html</id>
    <published>2025-04-30T15:23:59.000Z</published>
    <updated>2025-04-30T15:23:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络结构">网络结构</h2><p>区块链网络是p2p拓扑扁平结构，每个节点既是服务器也是客户端。</p><h2 id="节点类型">节点类型</h2><h3 id="节点成员分类">节点成员分类</h3><ul><li>矿工</li><li>全节点</li><li>SPV简单支付验证</li></ul><h3 id="全节点">全节点</h3><p>全节点记录了完整区块信息，同时提供了路由操作。</p><h3 id="SPV节点">SPV节点</h3><p>SPV不存放全部，而是一个交易子集，比如，发送到某个指定地址的交易(如全部发给Alice的交易)。</p><h2 id="交易同步机制">交易同步机制</h2><p>交易场景如下：<br><img src="https://cdn-a.markji.com/files/680f7bc96092fd692cbd1817_hd.png?e=1746029138069&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4eldrch0jXTVfMw_MgBc06yr5XM=" alt=""><br>用一个version进行节点间的通信，判断双方谁的链更长，从而和中心节点或者对方更新链信息。</p>]]></content>
    
    
    <summary type="html">区块链P2P网络的结构特点及节点类型详解</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="P2P网络" scheme="https://www.magicat.cc/tags/P2P%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>区块链核心代码4</title>
    <link href="https://www.magicat.cc/posts/blockchain-wallet.html"/>
    <id>https://www.magicat.cc/posts/blockchain-wallet.html</id>
    <published>2025-04-29T15:50:37.000Z</published>
    <updated>2025-04-29T15:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="钱包基础结构">钱包基础结构</h2><h3 id="1-钱包结构体">1. 钱包结构体</h3><p>新建钱包结构体，里面有：</p><ul><li>公私钥对</li><li>构造函数</li><li>辅助函数</li></ul><h3 id="2-地址生成">2. 地址生成</h3><p>给钱包增加getAddress成员函数，执行以下步骤：</p><ol><li>对公钥执行哈希</li><li>对①结果加上版本信息</li><li>对②结果哈希两次</li><li>拼接②结果和③结果</li><li>对④结果执行Base56算法</li></ol><h2 id="交易结构优化">交易结构优化</h2><h3 id="3-交易结构修改">3. 交易结构修改</h3><ul><li>input中加入自身公钥和签名</li><li>output还是放value和公钥</li></ul><h2 id="安全机制">安全机制</h2><h3 id="4-鉴权系统">4. 鉴权系统</h3><p>提供一系列鉴权函数，检验公钥是否合法。</p><h3 id="5-签名系统">5. 签名系统</h3><p>提供签名和验证签名的函数：</p><ul><li>对自身公钥所引用的输出的公钥(UTXO)和value执行签名</li><li>修改unspendutxo函数，把鉴权逻辑改成使用签名</li></ul>]]></content>
    
    
    <summary type="html">区块链系统中钱包结构及其加密验证机制的实现</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="密码学" scheme="https://www.magicat.cc/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>比特币加密算法</title>
    <link href="https://www.magicat.cc/posts/bitcoin-encryption.html"/>
    <id>https://www.magicat.cc/posts/bitcoin-encryption.html</id>
    <published>2025-04-29T15:48:50.000Z</published>
    <updated>2025-04-29T15:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="身份标识">身份标识</h2><p>在比特币中，身份本质上是一对公钥和私钥。</p><p>但是公钥和私钥本质上只是随机字符序列，人类无法肉眼读取，使用Base58编码转换，同时可以解码回去。</p><h2 id="数字签名">数字签名</h2><p>使用数字签名保证：</p><ul><li>数据传输过程中不被修改</li><li>数据的发送方可以被确定</li><li>发送方无法否认发送过的事实</li></ul><h2 id="密钥生成">密钥生成</h2><h3 id="私钥生成">私钥生成</h3><p>比特币使用椭圆曲线生成私钥，随机选取在 0 与 2^2^56中的数，略小于可观测宇宙原子数。</p><h3 id="公钥生成">公钥生成</h3><p>公钥本质上是私钥在椭圆上的x轴和y轴相加。</p><h2 id="ECDSA签名">ECDSA签名</h2><p>比特币使用ECDSA对数据进行签名。</p><p>签名需要：</p><ul><li>待签名数据</li><li>私钥</li></ul><p>验证需要：</p><ul><li>被签名数据</li><li>公钥</li><li>签名</li></ul><h2 id="交易验证">交易验证</h2><p>当一个人发送币的时候，要在input中带上：</p><ul><li>自己的公钥（用于匹配utxo）</li><li>整个交易的一个签名（由自己创建）</li></ul><p>比特币网络其他节点也会检查：</p><ul><li>这个公钥是否引用合法</li><li>签名是否可以用这个人的公钥验证</li></ul><h2 id="地址生成">地址生成</h2><p>经历一系列的算法后可以生成一个地址。</p><p>这个为真实的地址，甚至可以在https://blockchain.info/ 查询余额，只是余额为0而已。</p>]]></content>
    
    
    <summary type="html">比特币系统中的加密机制、数字签名及地址生成原理</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="比特币" scheme="https://www.magicat.cc/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    <category term="密码学" scheme="https://www.magicat.cc/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>区块链余额查询流程</title>
    <link href="https://www.magicat.cc/posts/blockchain-balance-query.html"/>
    <id>https://www.magicat.cc/posts/blockchain-balance-query.html</id>
    <published>2025-04-28T14:59:13.000Z</published>
    <updated>2025-04-28T14:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化阶段">初始化阶段</h2><p>创建一个空的 unspentTXs 切片，用来存储所有未花费的交易。</p><p>创建一个空的 spentTXOs 映射，存储已花费的交易输出（以 txID 和输出索引的方式标记已花费的输出）。</p><h2 id="迭代器获取">迭代器获取</h2><p>获取区块链的迭代器：<br>调用 bc.Iterator() 获取一个迭代器 bci，用于遍历区块链中的每一个区块。</p><h2 id="区块遍历过程">区块遍历过程</h2><h3 id="区块获取">区块获取</h3><p>使用 bci.Next() 获取下一个区块 block。</p><p>如果区块的 PrevBlockHash 长度为零，表示遍历到了区块链的头部，停止遍历。</p><h3 id="交易遍历">交易遍历</h3><p>对每个区块中的所有交易（block.Transactions），执行以下步骤：</p><ol><li>获取交易的 txID，并将其转为十六进制字符串。</li></ol><h3 id="输出检查">输出检查</h3><p>对当前交易的每个输出（tx.Vout），执行以下步骤：</p><ol><li>如果该输出已经在 spentTXOs 中标记为已花费，跳过该输出（继续检查下一个输出）</li><li>检查当前输出是否能被 address 解锁（out.CanBeUnlockedWith(address)）</li><li>如果可以解锁，则将当前交易添加到 unspentTXs 中</li></ol><h3 id="输入处理">输入处理</h3><p>如果当前交易不是一个 coinbase 交易（即它不是系统奖励的交易），则继续遍历交易的输入（tx.Vin）。</p><p>对每个输入，检查其是否能用 address 解锁（in.CanUnlockOutputWith(address)）：</p><ul><li>如果能解锁，说明该输入花费了某个输出</li><li>根据输入的 Txid 和 Vout，标记该输出为已花费，添加到 spentTXOs 中</li></ul><h2 id="遍历终止">遍历终止</h2><p>重复上述步骤直到遍历所有区块：<br>如果区块的 PrevBlockHash 长度为零，说明已经遍历到链头，退出遍历。</p><h2 id="结果返回">结果返回</h2><p>返回 unspentTXs，其中包含了所有与特定地址相关且未被花费的交易。<br><img src="https://cdn-a.markji.com/files/6809e95d6092fd692c50f89a_hd.png?e=1745854305346&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FKD3hsV1Cpif-krQweT7KM0gP_w=" alt=""></p>]]></content>
    
    
    <summary type="html">详细解析区块链系统中查询余额的具体实现流程</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="比特币" scheme="https://www.magicat.cc/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链核心代码3</title>
    <link href="https://www.magicat.cc/posts/blockchain-transaction.html"/>
    <id>https://www.magicat.cc/posts/blockchain-transaction.html</id>
    <published>2025-04-28T14:57:03.000Z</published>
    <updated>2025-04-28T14:57:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础数据结构">基础数据结构</h2><h3 id="1-交易结构">1. 交易结构</h3><p>定义交易结构体，包含：</p><ul><li>id</li><li>TXInput</li><li>TXOutput</li></ul><h3 id="2-交易输出结构">2. 交易输出结构</h3><p>定义TXOutput结构体，内部有：</p><ul><li>value（单位是satoshi，一聪，btc最小单位）</li><li>ScriptPubKey（锁定脚本，对方地址/公钥）</li></ul><p>注：value表示代金券上的金额，锁定脚本即代金券的使用规则，满足了才可以用。</p><h3 id="3-交易输入结构">3. 交易输入结构</h3><p>定义TXInput结构体，内部有：</p><ul><li>TXid（代金券编号）</li><li>Vout（输出索引）</li><li>ScriptSip（解锁脚本）</li></ul><p>注：</p><ul><li>Vout是用来告诉系统上次交易的使用输出，也是告诉商店要用哪张代金券（本次输入）</li><li>本次输入是之前的输出，除了新块，否则都要引用之前的输出，故其实没有被引用的输出就是余额</li></ul><h2 id="功能实现">功能实现</h2><h3 id="4-创世交易">4. 创世交易</h3><p>定义创世区块的TX函数，这个没有前vin，只有输出，也没有解锁脚本（为空）。</p><h3 id="5-区块结构修改">5. 区块结构修改</h3><p>修改block结构体的成员，把data换成Transactions函数。</p><h3 id="6-代码适配">6. 代码适配</h3><p>把之前一切关于data的代码进行修改换成transaction，同时修改创建区块链的函数，这个函数会接收一个address给创世矿工，且之前的工作量证明需要把data换成TX。</p><h3 id="7-余额查询基础">7. 余额查询基础</h3><p>定义能否解锁和锁定输入输出的函数（这里只是简单查询一下是否是自己的密钥）。</p><h3 id="8-未花费输出查询">8. 未花费输出查询</h3><p>定义FindUnspentTransactions函数，创建哈希表存储所有已花费的输出（就是每个后vin对应的前vout），那些没有后面vin的vout就是余额。</p><h3 id="9-余额计算">9. 余额计算</h3><p>定义getbalance函数，用于把Find函数找出来的UTXOs（未交易输出）合并起来算除余额。</p><h3 id="10-交易生成">10. 交易生成</h3><p>定义NewUTXOTransaction用于生成交易信息。</p><h3 id="11-可用输出查询">11. 可用输出查询</h3><p>定义FindSpendableOutputs，找到未花费的金额，并且确保金额足够。</p><h3 id="12-转账功能">12. 转账功能</h3><p>定义send函数用于发送币。</p>]]></content>
    
    
    <summary type="html">区块链系统中交易机制的详细实现方案</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="比特币" scheme="https://www.magicat.cc/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链核心代码2</title>
    <link href="https://www.magicat.cc/posts/blockchain-persistence.html"/>
    <id>https://www.magicat.cc/posts/blockchain-persistence.html</id>
    <published>2025-04-28T14:55:28.000Z</published>
    <updated>2025-04-28T14:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区块链存储机制">区块链存储机制</h2><p>理论上任何的数据库都可以，bitcoin本质上是分布式存储。</p><p>但是这边先讨论存储，若使用字节型数据库则需要把block给序列化存储。</p><p>bitcoin的存储一般分为了blocks和chainstate：</p><ul><li>blocks里面就是每个区块的内容</li><li>chainstate存放着剩余的比特币数量</li></ul><p>注意：为了性能可以单独存储每一块，这样就不需要把整个链拿出来，但是一起存较为简单。</p><h2 id="核心实现">核心实现</h2><h3 id="1-序列化">1. 序列化</h3><p>提供序列化的block成员函数，把自身序列化。</p><h3 id="2-反序列化">2. 反序列化</h3><p>提供反序列化的非成员函数，会返回一个block。</p><h3 id="3-创世块存储">3. 创世块存储</h3><p>修改创建创世块函数，打开数据库(键值对)，读取blocksBucket：</p><ul><li>若没有则创建并往里面放入创世块和l键</li><li>若已经存在了则读取l键，然后返回blockchain(这个blockchain，内部加一个了db的成员指针)</li></ul><p>注意：l键始终存储了最后一个块的哈希值，且存放一个块的时候以他的哈希为key，序列化为value，可以通过get(key)获取value。</p><h3 id="4-区块添加修改">4. 区块添加修改</h3><p>修改addblock函数，修改前哈希的来源为数据库中的l键。</p><h3 id="5-遍历功能">5. 遍历功能</h3><p>添加遍历blockchain函数，l键到创世块，先通过l键获取最后一个区块，然后用每个区块的前哈希来更新当前哈希继续遍历。</p><h3 id="6-迭代器实现">6. 迭代器实现</h3><ul><li>新增迭代器类</li><li>新增blockchain成员函数，创建迭代器</li></ul><p>当前类图：</p>]]></content>
    
    
    <summary type="html">区块链系统的数据持久化存储及命令行接口的实现</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="数据库" scheme="https://www.magicat.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>区块链核心代码1</title>
    <link href="https://www.magicat.cc/posts/blockchain-core-implementation.html"/>
    <id>https://www.magicat.cc/posts/blockchain-core-implementation.html</id>
    <published>2025-04-28T14:52:59.000Z</published>
    <updated>2025-04-28T14:52:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础数据结构">基础数据结构</h2><h3 id="1-区块结构">1. 区块结构</h3><p>定义区块头struct block，包含：</p><ul><li>时间戳</li><li>前哈希</li><li>data</li><li>当前哈希</li></ul><h3 id="2-哈希计算">2. 哈希计算</h3><p>给block提供计算当前哈希的方法。</p><h3 id="3-区块链结构">3. 区块链结构</h3><p>定义区块链struct blockchain，内部有block数组。</p><h2 id="区块操作">区块操作</h2><h3 id="4-区块添加">4. 区块添加</h3><p>定义addblock函数，提供添加区块的方法。</p><h3 id="5-创世块">5. 创世块</h3><p>定义添加创世块函数。</p><h2 id="工作量证明机制">工作量证明机制</h2><h3 id="6-POW结构">6. POW结构</h3><p>定义工作量证明结构体struct ProofOfWork，内部有：</p><ul><li>block</li><li>target(000010000000)</li></ul><p>定义其构造函数，就是一个大整数，若计算值小于target，则说明至少前五位为0。</p><h3 id="7-数据准备">7. 数据准备</h3><p>定义&quot;准备数据&quot;的ProofOfWork的成员函数，拼接用于哈希的数据，返回的data会被用于哈希。</p><h3 id="8-运行验证">8. 运行验证</h3><p>定义Run的成员函数，循环++，查询是否满足条件，满足了就退出for循环。<br>注意：要定义一个nonce的最大值防止溢出，溢出了也退出。</p><h2 id="功能完善">功能完善</h2><h3 id="9-添加验证">9. 添加验证</h3><p>修改addblock函数，在其中调用工作量证明，run成功了才执行添加。</p><h3 id="10-有效性验证">10. 有效性验证</h3><p>定义确认区块有效区块，确认一下之前Run不是因为溢出而结束。</p>]]></content>
    
    
    <summary type="html">区块链系统的核心数据结构和工作量证明机制的具体实现</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>区块链基础知识</title>
    <link href="https://www.magicat.cc/posts/blockchain-basics.html"/>
    <id>https://www.magicat.cc/posts/blockchain-basics.html</id>
    <published>2025-04-28T14:50:36.000Z</published>
    <updated>2025-04-28T14:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易区块结构">简易区块结构</h2><p>区块内容包含：</p><ul><li>时间戳</li><li>前哈希</li><li>当前哈希</li><li>实际data</li></ul><p>当前哈希的计算方法：<br>SHA256(时间戳,前哈希,实际data)</p><p>实际data存放的数据为交易信息。</p><p>区块链本质上为一个数据库，每一个块都连到前一个块。</p><h2 id="共识机制">共识机制</h2><p>因为是分布式数据库，且没有独裁者，故加入一个块需要获得其他参与者的同意。</p><h3 id="工作量证明">工作量证明</h3><p>需要经历一系列繁重的运算才可以获得加入块的权力。</p><h3 id="哈希函数">哈希函数</h3><p>哈希函数被广泛用于检测数据的一致性，哈希值和原始数据是一一对应的，可以用来检测文件是否损坏，比较一下传输之后的哈希和作者提供的哈希。</p><h2 id="比特币的算法">比特币的算法</h2><p>把时间戳，前哈希，实际data然后用一个计数器不断+1来执行哈希，直到哈希值前20为0(难度为20)，概率为1/2^20。</p><p>注意：</p><ul><li>nonce为计数器，一个密码学术语</li><li>因为全是0开头，所以只要是否比较小于0x000000…，就知道是否前20位都是0</li></ul>]]></content>
    
    
    <summary type="html">区块链的基本概念、工作原理及比特币共识机制简介</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="比特币" scheme="https://www.magicat.cc/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>构造函数中的虚函数与继承</title>
    <link href="https://www.magicat.cc/posts/constructor-virtual-function.html"/>
    <id>https://www.magicat.cc/posts/constructor-virtual-function.html</id>
    <published>2025-04-23T15:14:48.000Z</published>
    <updated>2025-04-23T15:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造析构中的虚函数调用"><a href="#构造析构中的虚函数调用" class="headerlink" title="构造析构中的虚函数调用"></a>构造析构中的虚函数调用</h2><p>在构造和析构过程中，虚函数无法动态绑定到派生类的版本，只能绑定到基类的版本因为派生类的构造在基类之后，而析构又在基类之前，此时都处于未完成的状态。</p><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>派生类可以重用其直接基类定义的构造函数，但不能继承默认、拷贝和移动构造。</p><p>通过using 基类名::基类构造函数来使用，编译器会调用基类的构造函数初始化基类部分，但不会继承构造函数的具体实现（即函数体内容不会被继承）。<br><img src="https://cdn-a.markji.com/files/6800f32575151df2bb69a644_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:S4uCS8guDfEPvnjKe4miK71hFys=" alt=""><br><img src="https://cdn-a.markji.com/files/6800f4cd75151df2bb69de06_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:DCJfkqaJkhZWLn-IvPrYuPylqTE=" alt=""></p><h2 id="默认参数的继承"><a href="#默认参数的继承" class="headerlink" title="默认参数的继承"></a>默认参数的继承</h2><p>当基类构造函数包含默认参数时，派生类并不会直接继承这些默认参数，而是会为派生类生成多个构造函数，每个构造函数省略了基类构造函数中一个带默认值的参数。</p><p>两种类型，一种直接去掉默认参数，一种将默认参数转换为默认值。<br><img src="https://cdn-a.markji.com/files/6800f80675151df2bb6a9773_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:9sBRyoKAO1e8NTYMoPOY-Y0GO9Y=" alt=""></p>]]></content>
    
    
    <summary type="html">C++中构造函数和析构函数中虚函数的行为及构造函数继承机制详解</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>类作用域的继承</title>
    <link href="https://www.magicat.cc/posts/class-scope-inheritance.html"/>
    <id>https://www.magicat.cc/posts/class-scope-inheritance.html</id>
    <published>2025-04-23T15:10:56.000Z</published>
    <updated>2025-04-23T15:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域嵌套规则"><a href="#作用域嵌套规则" class="headerlink" title="作用域嵌套规则"></a>作用域嵌套规则</h2><p>派生类作用域嵌套在其基类的作用域之中，如果一个名字在派生类作用域无法解析，编译器会到外层基类作用域中寻找。</p><h2 id="名字查找与静态类型"><a href="#名字查找与静态类型" class="headerlink" title="名字查找与静态类型"></a>名字查找与静态类型</h2><p>之前写过基类的指针或引用可以传派生类，但此时这个指针依然只能调用基类成员，不能调用独属于传进来的派生类的成员，因为编译时会识别静态类型进行名字查找。</p><h2 id="名字隐藏"><a href="#名字隐藏" class="headerlink" title="名字隐藏"></a>名字隐藏</h2><p>派生类的成员将隐藏同名的基类成员，但可以通过作用域运算符显式调用隐藏的成员。</p><h2 id="覆盖重载函数"><a href="#覆盖重载函数" class="headerlink" title="覆盖重载函数"></a>覆盖重载函数</h2><p>派生类中只要出现和基类同名的函数，就会覆盖掉基类中该函数所有版本。</p><p>可以先用using把所有基类的重载搬过来，就能只覆盖自己想要覆盖的那个版本。<br><img src="https://cdn-a.markji.com/files/67f5c4c4a5d66136f3d79f3a_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4TILibPUCQRPIFMsGGTNp1vKMuA=" alt=""></p>]]></content>
    
    
    <summary type="html">C++中类作用域继承机制及名字查找规则详解</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>虚析构函数与继承中的拷贝控制</title>
    <link href="https://www.magicat.cc/posts/virtual-destructor-copy-control.html"/>
    <id>https://www.magicat.cc/posts/virtual-destructor-copy-control.html</id>
    <published>2025-04-23T15:01:42.000Z</published>
    <updated>2025-04-23T15:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚析构函数">虚析构函数</h2><p>如果一个类会作为基类使用，就必须把它的析构函数设为虚函数，否则通过基类指针删除派生类对象会是未定义行为。</p><p>只要一个类显式定义了析构函数（包括虚析构函数，即使是 =default），在这个类及其派生类中，编译器都不会自动生成移动构造函数和移动赋值运算符。</p><p>如果还想要移动操作，就要手动写出来或默认声明它们。</p><h2 id="合成拷贝控制与继承">合成拷贝控制与继承</h2><p>合成的拷贝控制函数会自动处理对象的创建、复制和销毁，先处理基类的成员，再处理派生类的成员。</p><p>如果基类的拷贝控制函数被删除或不可访问，派生类的相关拷贝控制函数也会被删除。</p><p>如果基类没有移动构造函数，派生类也不能默认有移动构造函数。如果派生类想要支持拷贝或移动操作，它必须自己实现这些操作，并且处理好基类部分的拷贝或移动。</p><h2 id="派生类的拷贝控制成员">派生类的拷贝控制成员</h2><p>和派生类的构造函数一样，当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</p><p>但析构函数只负责销毁派生类自己分配的成员，基类部分的析构会被自动调用执行。</p><h3 id="拷贝构造函数">拷贝构造函数</h3><p>通常直接使用基类的拷贝构造函数初始化基类部分，但要在初始化列表显式调用。<br><img src="https://cdn-a.markji.com/files/6800b4b12d056573639cf116_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:PoudJ85t7zVQbnAazX4tqzDXcY0=" alt=""></p><h3 id="拷贝赋值运算符">拷贝赋值运算符</h3><p>拷贝赋值也要在函数体内显式调用基类赋值运算符，否则不会自动调用。<br><img src="https://cdn-a.markji.com/files/6800b5472d056573639d06d8_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:8jppwX4IScpCav6_n_0R564_Hbs=" alt=""></p><h3 id="析构函数">析构函数</h3><p>基类析构函数可以被自动调用。<br><img src="https://cdn-a.markji.com/files/6800b6df75151df2bb621783_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4WB0VxVK8x4_5yAhIv_sguCSATQ=" alt=""></p>]]></content>
    
    
    <summary type="html">C++中虚析构函数的作用及继承关系下的拷贝控制成员详解</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>抽象基类与访问控制</title>
    <link href="https://www.magicat.cc/posts/abstract-base-class.html"/>
    <id>https://www.magicat.cc/posts/abstract-base-class.html</id>
    <published>2025-04-23T14:59:11.000Z</published>
    <updated>2025-04-23T14:59:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>在虚函数声明语句后面添加=0定义纯虚函数，之后不能在类内为纯虚函数提供定义。</p><p>含义纯虚函数的类是抽象基类，不能直接创建一个抽象基类的对象。</p><p>派生类构造函数只初始化它的直接基类。</p><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>protected 成员是”继承可见”的，但必须通过”自己继承来的一份”去访问；继承方式则控制”你能不能把你继承来的成员继续公开给外部或子类”。</p><h3 id="Protected成员访问规则"><a href="#Protected成员访问规则" class="headerlink" title="Protected成员访问规则"></a>Protected成员访问规则</h3><p>protected成员只能被派生类和友元函数访问，不能被类外部访问。</p><p>子类及其友元只能通过自己的类对象访问自己继承来的父类protected成员，不能直接通过父类对象访问原先父类对象中的 protected 成员。<br><img src="https://cdn-a.markji.com/files/67f54a17c7682418c3ba10ff_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RwgZuv6gWWkOZpzzn3EbCmewKJg=" alt=""></p><h3 id="友元关系"><a href="#友元关系" class="headerlink" title="友元关系"></a>友元关系</h3><p>友元关系不能传递也不能继承。</p><h3 id="继承方式与访问权限"><a href="#继承方式与访问权限" class="headerlink" title="继承方式与访问权限"></a>继承方式与访问权限</h3><p>派生类的继承方式决定了外部对象对派生类成员的访问权限。<br><img src="https://cdn-a.markji.com/files/67f54aecc7682418c3ba2875_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:oi4Yb307pwlRkFO32aT4H6TcDWI=" alt=""></p><h3 id="修改访问权限"><a href="#修改访问权限" class="headerlink" title="修改访问权限"></a>修改访问权限</h3><p>using声明可以改变个别成员的可访问性。<br><img src="https://cdn-a.markji.com/files/67f54c96a5d66136f3d2bbb6_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:oE6rawLQqUT3ZBqRhzncksdrW68=" alt=""></p><h3 id="class与struct的区别"><a href="#class与struct的区别" class="headerlink" title="class与struct的区别"></a>class与struct的区别</h3><p>用class定义的派生类默认私有继承，struct定义的派生类默认公有继承。</p><p>这是这两个关键字的唯一区别。</p>]]></content>
    
    
    <summary type="html">C++中抽象基类的概念及继承中的访问控制详解</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>类型转换与虚函数</title>
    <link href="https://www.magicat.cc/posts/type-conversion-virtual-function.html"/>
    <id>https://www.magicat.cc/posts/type-conversion-virtual-function.html</id>
    <published>2025-04-23T14:54:29.000Z</published>
    <updated>2025-04-23T14:54:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型转换与继承">类型转换与继承</h2><p>可以将基类指针/引用绑定到派生类对象上。也就是可以把派生类对象当成基类对象使用（需要传基类对象的参数也可以传派生类对象）但不能将基类转换成派生类。</p><h2 id="静态类型与动态类型">静态类型与动态类型</h2><ul><li><strong>静态类型</strong>：变量或表达式在编译时确定的类型，由声明决定。代码写下时，编译器就能知道其静态类型</li><li><strong>动态类型</strong>：变量或表达式在运行时所表示的对象的实际类型。只有当程序运行时，才知道变量指向的具体对象是什么</li></ul><p>基类指针或引用可以指向派生类对象，此时，静态类型仍然是基类类型，动态类型则是运行时绑定的派生类类型。即该指针或引用只能访问基类的成员，其中非虚函数调用的是基类的版本，虚函数会动态绑定到派生类定义的版本。<br><img src="https://cdn-a.markji.com/files/67eb4702205d5713c0ce74ea_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:xDjxTZGidb8FFlxQqfvMlHX9tFw=" alt=""></p><p>如果是直接将派生类对象赋值给基类，仅保留基类部分，派生类的成员被丢弃。之后，该对象的动态类型就变成了基类。<br><img src="https://cdn-a.markji.com/files/67eb464d205d5713c0ce5701_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Qux9clPeNCQx9tzyd3Y_v054KGg=" alt=""></p><h2 id="虚函数特性">虚函数特性</h2><p>所有虚函数都必须有定义。</p><p>当某个虚函数通过指针或引用调用时，对虚函数的调用在运行时才被解析。</p><h3 id="覆盖规则">覆盖规则</h3><p>如果要在派生类中覆盖继承来的虚函数，形参类型必须完全一致。</p><p>否则名字相同但参数列表不同的函数会成为独立的新函数，而不是覆盖原有的。</p><p>因为声明在内层作用域的函数并不会重载声明在外层作用域的函数，而是隐藏外层的。</p><h3 id="特殊说明符">特殊说明符</h3><ul><li>可以在派生类中使用override标记，此时如果没有覆盖原有的虚函数，编译器会报错</li><li>单独将函数指定为final，之后任何尝试覆盖该函数的操作都会报错</li></ul><h3 id="其他注意事项">其他注意事项</h3><ul><li>虚函数总是使用基类中定义的默认实参</li><li>可以使用作用域运算符规避虚函数的动态绑定<br><img src="https://cdn-a.markji.com/files/67eb4e06205d5713c0cf9775_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:N9gNCJ2GaOGWb7oPsrg_e7l4VVE=" alt=""></li></ul>]]></content>
    
    
    <summary type="html">C++中的类型转换、继承关系以及虚函数的详细解析</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Qt非阻塞延迟实现</title>
    <link href="https://www.magicat.cc/posts/qt-non-blocking-delay.html"/>
    <id>https://www.magicat.cc/posts/qt-non-blocking-delay.html</id>
    <published>2025-04-15T15:23:37.000Z</published>
    <updated>2025-04-15T15:23:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QTimer-singleShot简介"><a href="#QTimer-singleShot简介" class="headerlink" title="QTimer::singleShot简介"></a>QTimer::singleShot简介</h2><p><img src="https://cdn-a.markji.com/files/68076cb12d05657363373ede_hd.png?e=1745509985100&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:iFm9_QupELxQqTeUfrVVlBBltxQ=" alt=""></p><h2 id="QEventLoop简介"><a href="#QEventLoop简介" class="headerlink" title="QEventLoop简介"></a>QEventLoop简介</h2><p>QEventLoop 是控制事件循环的类，它在 Qt 程序中管理事件队列，并将事件分发到相应的对象。</p><h2 id="事件循环控制"><a href="#事件循环控制" class="headerlink" title="事件循环控制"></a>事件循环控制</h2><p>exec()函数启动事件循环，等待事件的发生。直到调用 quit() 方法或事件循环结束，程序才会继续执行后面的代码。</p><p>等待的过程是非阻塞的，可以在等待过程中响应其他事件。</p><p>quit() 用于退出事件循环。<br><img src="https://cdn-a.markji.com/files/680775f56092fd692c29d001_hd.png?e=1745509985100&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:mq7ppAE5sdGRE2hcmUV0Qew__TU=" alt=""></p>]]></content>
    
    
    <summary type="html">Qt中使用QEventLoop实现非阻塞延迟的方法详解</summary>
    
    
    
    <category term="GUI开发" scheme="https://www.magicat.cc/categories/GUI%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="Qt" scheme="https://www.magicat.cc/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt对象树机制</title>
    <link href="https://www.magicat.cc/posts/qt-object-tree.html"/>
    <id>https://www.magicat.cc/posts/qt-object-tree.html</id>
    <published>2025-04-15T15:21:43.000Z</published>
    <updated>2025-04-15T15:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Qt对象继承体系"><a href="#Qt对象继承体系" class="headerlink" title="Qt对象继承体系"></a>Qt对象继承体系</h2><p>QObject是大多数对象的基类，QWidget继承于QObject，又是大多数页面和窗口组件的基类。</p><h2 id="对象树结构"><a href="#对象树结构" class="headerlink" title="对象树结构"></a>对象树结构</h2><p>当QOject及其子类之间建立父子关系时，所有子类对象会被加入父类对象一个成员变量名为children的列表中。</p><p>当父对象析构时，children里的所有子对象也会一起析构；如果子对象先被析构，会自动被父对象的children列表移除。<br><img src="https://cdn-a.markji.com/files/67fa2e507f917e87d7c3bff6_hd.png?e=1745509985100&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:7tDj9yoaV3bsuvNjJO3b6ZICfqE=" alt=""></p><h2 id="父对象设置"><a href="#父对象设置" class="headerlink" title="父对象设置"></a>父对象设置</h2><p>所以一般在创建qt子对象时，会先在构造函数初始化列表就指定parent对象。</p><p>默认写法可以是ReadThread(QObject *parent = nullptr)，父对象为空。</p>]]></content>
    
    
    <summary type="html">Qt框架中的对象树结构及其内存管理机制详解</summary>
    
    
    
    <category term="GUI开发" scheme="https://www.magicat.cc/categories/GUI%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="Qt" scheme="https://www.magicat.cc/tags/Qt/"/>
    
  </entry>
  
</feed>
