<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>magic station</title>
  
  
  <link href="https://www.magicat.cc/atom.xml" rel="self"/>
  
  <link href="https://www.magicat.cc/"/>
  <updated>2025-04-29T15:50:37.000Z</updated>
  <id>https://www.magicat.cc/</id>
  
  <author>
    <name>MagicCat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链钱包实现</title>
    <link href="https://www.magicat.cc/posts/blockchain-wallet.html"/>
    <id>https://www.magicat.cc/posts/blockchain-wallet.html</id>
    <published>2025-04-29T15:50:37.000Z</published>
    <updated>2025-04-29T15:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="钱包基础结构">钱包基础结构</h2><h3 id="1-钱包结构体">1. 钱包结构体</h3><p>新建钱包结构体，里面有：</p><ul><li>公私钥对</li><li>构造函数</li><li>辅助函数</li></ul><h3 id="2-地址生成">2. 地址生成</h3><p>给钱包增加getAddress成员函数，执行以下步骤：</p><ol><li>对公钥执行哈希</li><li>对①结果加上版本信息</li><li>对②结果哈希两次</li><li>拼接②结果和③结果</li><li>对④结果执行Base56算法</li></ol><h2 id="交易结构优化">交易结构优化</h2><h3 id="3-交易结构修改">3. 交易结构修改</h3><ul><li>input中加入自身公钥和签名</li><li>output还是放value和公钥</li></ul><h2 id="安全机制">安全机制</h2><h3 id="4-鉴权系统">4. 鉴权系统</h3><p>提供一系列鉴权函数，检验公钥是否合法。</p><h3 id="5-签名系统">5. 签名系统</h3><p>提供签名和验证签名的函数：</p><ul><li>对自身公钥所引用的输出的公钥(UTXO)和value执行签名</li><li>修改unspendutxo函数，把鉴权逻辑改成使用签名</li></ul>]]></content>
    
    
    <summary type="html">区块链系统中钱包结构及其加密验证机制的实现</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="密码学" scheme="https://www.magicat.cc/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>比特币加密算法</title>
    <link href="https://www.magicat.cc/posts/bitcoin-encryption.html"/>
    <id>https://www.magicat.cc/posts/bitcoin-encryption.html</id>
    <published>2025-04-29T15:48:50.000Z</published>
    <updated>2025-04-29T15:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="身份标识">身份标识</h2><p>在比特币中，身份本质上是一对公钥和私钥。</p><p>但是公钥和私钥本质上只是随机字符序列，人类无法肉眼读取，使用Base58编码转换，同时可以解码回去。</p><h2 id="数字签名">数字签名</h2><p>使用数字签名保证：</p><ul><li>数据传输过程中不被修改</li><li>数据的发送方可以被确定</li><li>发送方无法否认发送过的事实</li></ul><h2 id="密钥生成">密钥生成</h2><h3 id="私钥生成">私钥生成</h3><p>比特币使用椭圆曲线生成私钥，随机选取在 0 与 2^2^56中的数，略小于可观测宇宙原子数。</p><h3 id="公钥生成">公钥生成</h3><p>公钥本质上是私钥在椭圆上的x轴和y轴相加。</p><h2 id="ECDSA签名">ECDSA签名</h2><p>比特币使用ECDSA对数据进行签名。</p><p>签名需要：</p><ul><li>待签名数据</li><li>私钥</li></ul><p>验证需要：</p><ul><li>被签名数据</li><li>公钥</li><li>签名</li></ul><h2 id="交易验证">交易验证</h2><p>当一个人发送币的时候，要在input中带上：</p><ul><li>自己的公钥（用于匹配utxo）</li><li>整个交易的一个签名（由自己创建）</li></ul><p>比特币网络其他节点也会检查：</p><ul><li>这个公钥是否引用合法</li><li>签名是否可以用这个人的公钥验证</li></ul><h2 id="地址生成">地址生成</h2><p>经历一系列的算法后可以生成一个地址。</p><p>这个为真实的地址，甚至可以在https://blockchain.info/ 查询余额，只是余额为0而已。</p>]]></content>
    
    
    <summary type="html">比特币系统中的加密机制、数字签名及地址生成原理</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="比特币" scheme="https://www.magicat.cc/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    <category term="密码学" scheme="https://www.magicat.cc/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>区块链余额查询流程</title>
    <link href="https://www.magicat.cc/posts/blockchain-balance-query.html"/>
    <id>https://www.magicat.cc/posts/blockchain-balance-query.html</id>
    <published>2025-04-28T14:59:13.000Z</published>
    <updated>2025-04-28T14:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化阶段">初始化阶段</h2><p>创建一个空的 unspentTXs 切片，用来存储所有未花费的交易。</p><p>创建一个空的 spentTXOs 映射，存储已花费的交易输出（以 txID 和输出索引的方式标记已花费的输出）。</p><h2 id="迭代器获取">迭代器获取</h2><p>获取区块链的迭代器：<br>调用 bc.Iterator() 获取一个迭代器 bci，用于遍历区块链中的每一个区块。</p><h2 id="区块遍历过程">区块遍历过程</h2><h3 id="区块获取">区块获取</h3><p>使用 bci.Next() 获取下一个区块 block。</p><p>如果区块的 PrevBlockHash 长度为零，表示遍历到了区块链的头部，停止遍历。</p><h3 id="交易遍历">交易遍历</h3><p>对每个区块中的所有交易（block.Transactions），执行以下步骤：</p><ol><li>获取交易的 txID，并将其转为十六进制字符串。</li></ol><h3 id="输出检查">输出检查</h3><p>对当前交易的每个输出（tx.Vout），执行以下步骤：</p><ol><li>如果该输出已经在 spentTXOs 中标记为已花费，跳过该输出（继续检查下一个输出）</li><li>检查当前输出是否能被 address 解锁（out.CanBeUnlockedWith(address)）</li><li>如果可以解锁，则将当前交易添加到 unspentTXs 中</li></ol><h3 id="输入处理">输入处理</h3><p>如果当前交易不是一个 coinbase 交易（即它不是系统奖励的交易），则继续遍历交易的输入（tx.Vin）。</p><p>对每个输入，检查其是否能用 address 解锁（in.CanUnlockOutputWith(address)）：</p><ul><li>如果能解锁，说明该输入花费了某个输出</li><li>根据输入的 Txid 和 Vout，标记该输出为已花费，添加到 spentTXOs 中</li></ul><h2 id="遍历终止">遍历终止</h2><p>重复上述步骤直到遍历所有区块：<br>如果区块的 PrevBlockHash 长度为零，说明已经遍历到链头，退出遍历。</p><h2 id="结果返回">结果返回</h2><p>返回 unspentTXs，其中包含了所有与特定地址相关且未被花费的交易。<br><img src="https://cdn-a.markji.com/files/6809e95d6092fd692c50f89a_hd.png?e=1745854305346&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FKD3hsV1Cpif-krQweT7KM0gP_w=" alt=""></p>]]></content>
    
    
    <summary type="html">详细解析区块链系统中查询余额的具体实现流程</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="比特币" scheme="https://www.magicat.cc/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链核心代码3</title>
    <link href="https://www.magicat.cc/posts/blockchain-transaction.html"/>
    <id>https://www.magicat.cc/posts/blockchain-transaction.html</id>
    <published>2025-04-28T14:57:03.000Z</published>
    <updated>2025-04-28T14:57:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础数据结构">基础数据结构</h2><h3 id="1-交易结构">1. 交易结构</h3><p>定义交易结构体，包含：</p><ul><li>id</li><li>TXInput</li><li>TXOutput</li></ul><h3 id="2-交易输出结构">2. 交易输出结构</h3><p>定义TXOutput结构体，内部有：</p><ul><li>value（单位是satoshi，一聪，btc最小单位）</li><li>ScriptPubKey（锁定脚本，对方地址/公钥）</li></ul><p>注：value表示代金券上的金额，锁定脚本即代金券的使用规则，满足了才可以用。</p><h3 id="3-交易输入结构">3. 交易输入结构</h3><p>定义TXInput结构体，内部有：</p><ul><li>TXid（代金券编号）</li><li>Vout（输出索引）</li><li>ScriptSip（解锁脚本）</li></ul><p>注：</p><ul><li>Vout是用来告诉系统上次交易的使用输出，也是告诉商店要用哪张代金券（本次输入）</li><li>本次输入是之前的输出，除了新块，否则都要引用之前的输出，故其实没有被引用的输出就是余额</li></ul><h2 id="功能实现">功能实现</h2><h3 id="4-创世交易">4. 创世交易</h3><p>定义创世区块的TX函数，这个没有前vin，只有输出，也没有解锁脚本（为空）。</p><h3 id="5-区块结构修改">5. 区块结构修改</h3><p>修改block结构体的成员，把data换成Transactions函数。</p><h3 id="6-代码适配">6. 代码适配</h3><p>把之前一切关于data的代码进行修改换成transaction，同时修改创建区块链的函数，这个函数会接收一个address给创世矿工，且之前的工作量证明需要把data换成TX。</p><h3 id="7-余额查询基础">7. 余额查询基础</h3><p>定义能否解锁和锁定输入输出的函数（这里只是简单查询一下是否是自己的密钥）。</p><h3 id="8-未花费输出查询">8. 未花费输出查询</h3><p>定义FindUnspentTransactions函数，创建哈希表存储所有已花费的输出（就是每个后vin对应的前vout），那些没有后面vin的vout就是余额。</p><h3 id="9-余额计算">9. 余额计算</h3><p>定义getbalance函数，用于把Find函数找出来的UTXOs（未交易输出）合并起来算除余额。</p><h3 id="10-交易生成">10. 交易生成</h3><p>定义NewUTXOTransaction用于生成交易信息。</p><h3 id="11-可用输出查询">11. 可用输出查询</h3><p>定义FindSpendableOutputs，找到未花费的金额，并且确保金额足够。</p><h3 id="12-转账功能">12. 转账功能</h3><p>定义send函数用于发送币。</p>]]></content>
    
    
    <summary type="html">区块链系统中交易机制的详细实现方案</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="比特币" scheme="https://www.magicat.cc/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链核心代码2</title>
    <link href="https://www.magicat.cc/posts/blockchain-persistence.html"/>
    <id>https://www.magicat.cc/posts/blockchain-persistence.html</id>
    <published>2025-04-28T14:55:28.000Z</published>
    <updated>2025-04-28T14:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区块链存储机制">区块链存储机制</h2><p>理论上任何的数据库都可以，bitcoin本质上是分布式存储。</p><p>但是这边先讨论存储，若使用字节型数据库则需要把block给序列化存储。</p><p>bitcoin的存储一般分为了blocks和chainstate：</p><ul><li>blocks里面就是每个区块的内容</li><li>chainstate存放着剩余的比特币数量</li></ul><p>注意：为了性能可以单独存储每一块，这样就不需要把整个链拿出来，但是一起存较为简单。</p><h2 id="核心实现">核心实现</h2><h3 id="1-序列化">1. 序列化</h3><p>提供序列化的block成员函数，把自身序列化。</p><h3 id="2-反序列化">2. 反序列化</h3><p>提供反序列化的非成员函数，会返回一个block。</p><h3 id="3-创世块存储">3. 创世块存储</h3><p>修改创建创世块函数，打开数据库(键值对)，读取blocksBucket：</p><ul><li>若没有则创建并往里面放入创世块和l键</li><li>若已经存在了则读取l键，然后返回blockchain(这个blockchain，内部加一个了db的成员指针)</li></ul><p>注意：l键始终存储了最后一个块的哈希值，且存放一个块的时候以他的哈希为key，序列化为value，可以通过get(key)获取value。</p><h3 id="4-区块添加修改">4. 区块添加修改</h3><p>修改addblock函数，修改前哈希的来源为数据库中的l键。</p><h3 id="5-遍历功能">5. 遍历功能</h3><p>添加遍历blockchain函数，l键到创世块，先通过l键获取最后一个区块，然后用每个区块的前哈希来更新当前哈希继续遍历。</p><h3 id="6-迭代器实现">6. 迭代器实现</h3><ul><li>新增迭代器类</li><li>新增blockchain成员函数，创建迭代器</li></ul><p>当前类图：</p>]]></content>
    
    
    <summary type="html">区块链系统的数据持久化存储及命令行接口的实现</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="数据库" scheme="https://www.magicat.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>区块链核心代码1</title>
    <link href="https://www.magicat.cc/posts/blockchain-core-implementation.html"/>
    <id>https://www.magicat.cc/posts/blockchain-core-implementation.html</id>
    <published>2025-04-28T14:52:59.000Z</published>
    <updated>2025-04-28T14:52:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础数据结构">基础数据结构</h2><h3 id="1-区块结构">1. 区块结构</h3><p>定义区块头struct block，包含：</p><ul><li>时间戳</li><li>前哈希</li><li>data</li><li>当前哈希</li></ul><h3 id="2-哈希计算">2. 哈希计算</h3><p>给block提供计算当前哈希的方法。</p><h3 id="3-区块链结构">3. 区块链结构</h3><p>定义区块链struct blockchain，内部有block数组。</p><h2 id="区块操作">区块操作</h2><h3 id="4-区块添加">4. 区块添加</h3><p>定义addblock函数，提供添加区块的方法。</p><h3 id="5-创世块">5. 创世块</h3><p>定义添加创世块函数。</p><h2 id="工作量证明机制">工作量证明机制</h2><h3 id="6-POW结构">6. POW结构</h3><p>定义工作量证明结构体struct ProofOfWork，内部有：</p><ul><li>block</li><li>target(000010000000)</li></ul><p>定义其构造函数，就是一个大整数，若计算值小于target，则说明至少前五位为0。</p><h3 id="7-数据准备">7. 数据准备</h3><p>定义&quot;准备数据&quot;的ProofOfWork的成员函数，拼接用于哈希的数据，返回的data会被用于哈希。</p><h3 id="8-运行验证">8. 运行验证</h3><p>定义Run的成员函数，循环++，查询是否满足条件，满足了就退出for循环。<br>注意：要定义一个nonce的最大值防止溢出，溢出了也退出。</p><h2 id="功能完善">功能完善</h2><h3 id="9-添加验证">9. 添加验证</h3><p>修改addblock函数，在其中调用工作量证明，run成功了才执行添加。</p><h3 id="10-有效性验证">10. 有效性验证</h3><p>定义确认区块有效区块，确认一下之前Run不是因为溢出而结束。</p>]]></content>
    
    
    <summary type="html">区块链系统的核心数据结构和工作量证明机制的具体实现</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>区块链基础知识</title>
    <link href="https://www.magicat.cc/posts/blockchain-basics.html"/>
    <id>https://www.magicat.cc/posts/blockchain-basics.html</id>
    <published>2025-04-28T14:50:36.000Z</published>
    <updated>2025-04-28T14:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易区块结构">简易区块结构</h2><p>区块内容包含：</p><ul><li>时间戳</li><li>前哈希</li><li>当前哈希</li><li>实际data</li></ul><p>当前哈希的计算方法：<br>SHA256(时间戳,前哈希,实际data)</p><p>实际data存放的数据为交易信息。</p><p>区块链本质上为一个数据库，每一个块都连到前一个块。</p><h2 id="共识机制">共识机制</h2><p>因为是分布式数据库，且没有独裁者，故加入一个块需要获得其他参与者的同意。</p><h3 id="工作量证明">工作量证明</h3><p>需要经历一系列繁重的运算才可以获得加入块的权力。</p><h3 id="哈希函数">哈希函数</h3><p>哈希函数被广泛用于检测数据的一致性，哈希值和原始数据是一一对应的，可以用来检测文件是否损坏，比较一下传输之后的哈希和作者提供的哈希。</p><h2 id="比特币的算法">比特币的算法</h2><p>把时间戳，前哈希，实际data然后用一个计数器不断+1来执行哈希，直到哈希值前20为0(难度为20)，概率为1/2^20。</p><p>注意：</p><ul><li>nonce为计数器，一个密码学术语</li><li>因为全是0开头，所以只要是否比较小于0x000000…，就知道是否前20位都是0</li></ul>]]></content>
    
    
    <summary type="html">区块链的基本概念、工作原理及比特币共识机制简介</summary>
    
    
    
    <category term="区块链技术" scheme="https://www.magicat.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://www.magicat.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="比特币" scheme="https://www.magicat.cc/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>构造函数中的虚函数与继承</title>
    <link href="https://www.magicat.cc/posts/constructor-virtual-function.html"/>
    <id>https://www.magicat.cc/posts/constructor-virtual-function.html</id>
    <published>2025-04-23T15:14:48.000Z</published>
    <updated>2025-04-23T15:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造析构中的虚函数调用"><a href="#构造析构中的虚函数调用" class="headerlink" title="构造析构中的虚函数调用"></a>构造析构中的虚函数调用</h2><p>在构造和析构过程中，虚函数无法动态绑定到派生类的版本，只能绑定到基类的版本因为派生类的构造在基类之后，而析构又在基类之前，此时都处于未完成的状态。</p><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>派生类可以重用其直接基类定义的构造函数，但不能继承默认、拷贝和移动构造。</p><p>通过using 基类名::基类构造函数来使用，编译器会调用基类的构造函数初始化基类部分，但不会继承构造函数的具体实现（即函数体内容不会被继承）。<br><img src="https://cdn-a.markji.com/files/6800f32575151df2bb69a644_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:S4uCS8guDfEPvnjKe4miK71hFys=" alt=""><br><img src="https://cdn-a.markji.com/files/6800f4cd75151df2bb69de06_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:DCJfkqaJkhZWLn-IvPrYuPylqTE=" alt=""></p><h2 id="默认参数的继承"><a href="#默认参数的继承" class="headerlink" title="默认参数的继承"></a>默认参数的继承</h2><p>当基类构造函数包含默认参数时，派生类并不会直接继承这些默认参数，而是会为派生类生成多个构造函数，每个构造函数省略了基类构造函数中一个带默认值的参数。</p><p>两种类型，一种直接去掉默认参数，一种将默认参数转换为默认值。<br><img src="https://cdn-a.markji.com/files/6800f80675151df2bb6a9773_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:9sBRyoKAO1e8NTYMoPOY-Y0GO9Y=" alt=""></p>]]></content>
    
    
    <summary type="html">C++中构造函数和析构函数中虚函数的行为及构造函数继承机制详解</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>类作用域的继承</title>
    <link href="https://www.magicat.cc/posts/class-scope-inheritance.html"/>
    <id>https://www.magicat.cc/posts/class-scope-inheritance.html</id>
    <published>2025-04-23T15:10:56.000Z</published>
    <updated>2025-04-23T15:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域嵌套规则"><a href="#作用域嵌套规则" class="headerlink" title="作用域嵌套规则"></a>作用域嵌套规则</h2><p>派生类作用域嵌套在其基类的作用域之中，如果一个名字在派生类作用域无法解析，编译器会到外层基类作用域中寻找。</p><h2 id="名字查找与静态类型"><a href="#名字查找与静态类型" class="headerlink" title="名字查找与静态类型"></a>名字查找与静态类型</h2><p>之前写过基类的指针或引用可以传派生类，但此时这个指针依然只能调用基类成员，不能调用独属于传进来的派生类的成员，因为编译时会识别静态类型进行名字查找。</p><h2 id="名字隐藏"><a href="#名字隐藏" class="headerlink" title="名字隐藏"></a>名字隐藏</h2><p>派生类的成员将隐藏同名的基类成员，但可以通过作用域运算符显式调用隐藏的成员。</p><h2 id="覆盖重载函数"><a href="#覆盖重载函数" class="headerlink" title="覆盖重载函数"></a>覆盖重载函数</h2><p>派生类中只要出现和基类同名的函数，就会覆盖掉基类中该函数所有版本。</p><p>可以先用using把所有基类的重载搬过来，就能只覆盖自己想要覆盖的那个版本。<br><img src="https://cdn-a.markji.com/files/67f5c4c4a5d66136f3d79f3a_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4TILibPUCQRPIFMsGGTNp1vKMuA=" alt=""></p>]]></content>
    
    
    <summary type="html">C++中类作用域继承机制及名字查找规则详解</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>虚析构函数与继承中的拷贝控制</title>
    <link href="https://www.magicat.cc/posts/virtual-destructor-copy-control.html"/>
    <id>https://www.magicat.cc/posts/virtual-destructor-copy-control.html</id>
    <published>2025-04-23T15:01:42.000Z</published>
    <updated>2025-04-23T15:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚析构函数">虚析构函数</h2><p>如果一个类会作为基类使用，就必须把它的析构函数设为虚函数，否则通过基类指针删除派生类对象会是未定义行为。</p><p>只要一个类显式定义了析构函数（包括虚析构函数，即使是 =default），在这个类及其派生类中，编译器都不会自动生成移动构造函数和移动赋值运算符。</p><p>如果还想要移动操作，就要手动写出来或默认声明它们。</p><h2 id="合成拷贝控制与继承">合成拷贝控制与继承</h2><p>合成的拷贝控制函数会自动处理对象的创建、复制和销毁，先处理基类的成员，再处理派生类的成员。</p><p>如果基类的拷贝控制函数被删除或不可访问，派生类的相关拷贝控制函数也会被删除。</p><p>如果基类没有移动构造函数，派生类也不能默认有移动构造函数。如果派生类想要支持拷贝或移动操作，它必须自己实现这些操作，并且处理好基类部分的拷贝或移动。</p><h2 id="派生类的拷贝控制成员">派生类的拷贝控制成员</h2><p>和派生类的构造函数一样，当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</p><p>但析构函数只负责销毁派生类自己分配的成员，基类部分的析构会被自动调用执行。</p><h3 id="拷贝构造函数">拷贝构造函数</h3><p>通常直接使用基类的拷贝构造函数初始化基类部分，但要在初始化列表显式调用。<br><img src="https://cdn-a.markji.com/files/6800b4b12d056573639cf116_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:PoudJ85t7zVQbnAazX4tqzDXcY0=" alt=""></p><h3 id="拷贝赋值运算符">拷贝赋值运算符</h3><p>拷贝赋值也要在函数体内显式调用基类赋值运算符，否则不会自动调用。<br><img src="https://cdn-a.markji.com/files/6800b5472d056573639d06d8_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:8jppwX4IScpCav6_n_0R564_Hbs=" alt=""></p><h3 id="析构函数">析构函数</h3><p>基类析构函数可以被自动调用。<br><img src="https://cdn-a.markji.com/files/6800b6df75151df2bb621783_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4WB0VxVK8x4_5yAhIv_sguCSATQ=" alt=""></p>]]></content>
    
    
    <summary type="html">C++中虚析构函数的作用及继承关系下的拷贝控制成员详解</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>抽象基类与访问控制</title>
    <link href="https://www.magicat.cc/posts/abstract-base-class.html"/>
    <id>https://www.magicat.cc/posts/abstract-base-class.html</id>
    <published>2025-04-23T14:59:11.000Z</published>
    <updated>2025-04-23T14:59:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>在虚函数声明语句后面添加=0定义纯虚函数，之后不能在类内为纯虚函数提供定义。</p><p>含义纯虚函数的类是抽象基类，不能直接创建一个抽象基类的对象。</p><p>派生类构造函数只初始化它的直接基类。</p><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>protected 成员是”继承可见”的，但必须通过”自己继承来的一份”去访问；继承方式则控制”你能不能把你继承来的成员继续公开给外部或子类”。</p><h3 id="Protected成员访问规则"><a href="#Protected成员访问规则" class="headerlink" title="Protected成员访问规则"></a>Protected成员访问规则</h3><p>protected成员只能被派生类和友元函数访问，不能被类外部访问。</p><p>子类及其友元只能通过自己的类对象访问自己继承来的父类protected成员，不能直接通过父类对象访问原先父类对象中的 protected 成员。<br><img src="https://cdn-a.markji.com/files/67f54a17c7682418c3ba10ff_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RwgZuv6gWWkOZpzzn3EbCmewKJg=" alt=""></p><h3 id="友元关系"><a href="#友元关系" class="headerlink" title="友元关系"></a>友元关系</h3><p>友元关系不能传递也不能继承。</p><h3 id="继承方式与访问权限"><a href="#继承方式与访问权限" class="headerlink" title="继承方式与访问权限"></a>继承方式与访问权限</h3><p>派生类的继承方式决定了外部对象对派生类成员的访问权限。<br><img src="https://cdn-a.markji.com/files/67f54aecc7682418c3ba2875_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:oi4Yb307pwlRkFO32aT4H6TcDWI=" alt=""></p><h3 id="修改访问权限"><a href="#修改访问权限" class="headerlink" title="修改访问权限"></a>修改访问权限</h3><p>using声明可以改变个别成员的可访问性。<br><img src="https://cdn-a.markji.com/files/67f54c96a5d66136f3d2bbb6_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:oE6rawLQqUT3ZBqRhzncksdrW68=" alt=""></p><h3 id="class与struct的区别"><a href="#class与struct的区别" class="headerlink" title="class与struct的区别"></a>class与struct的区别</h3><p>用class定义的派生类默认私有继承，struct定义的派生类默认公有继承。</p><p>这是这两个关键字的唯一区别。</p>]]></content>
    
    
    <summary type="html">C++中抽象基类的概念及继承中的访问控制详解</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>类型转换与虚函数</title>
    <link href="https://www.magicat.cc/posts/type-conversion-virtual-function.html"/>
    <id>https://www.magicat.cc/posts/type-conversion-virtual-function.html</id>
    <published>2025-04-23T14:54:29.000Z</published>
    <updated>2025-04-23T14:54:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型转换与继承">类型转换与继承</h2><p>可以将基类指针/引用绑定到派生类对象上。也就是可以把派生类对象当成基类对象使用（需要传基类对象的参数也可以传派生类对象）但不能将基类转换成派生类。</p><h2 id="静态类型与动态类型">静态类型与动态类型</h2><ul><li><strong>静态类型</strong>：变量或表达式在编译时确定的类型，由声明决定。代码写下时，编译器就能知道其静态类型</li><li><strong>动态类型</strong>：变量或表达式在运行时所表示的对象的实际类型。只有当程序运行时，才知道变量指向的具体对象是什么</li></ul><p>基类指针或引用可以指向派生类对象，此时，静态类型仍然是基类类型，动态类型则是运行时绑定的派生类类型。即该指针或引用只能访问基类的成员，其中非虚函数调用的是基类的版本，虚函数会动态绑定到派生类定义的版本。<br><img src="https://cdn-a.markji.com/files/67eb4702205d5713c0ce74ea_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:xDjxTZGidb8FFlxQqfvMlHX9tFw=" alt=""></p><p>如果是直接将派生类对象赋值给基类，仅保留基类部分，派生类的成员被丢弃。之后，该对象的动态类型就变成了基类。<br><img src="https://cdn-a.markji.com/files/67eb464d205d5713c0ce5701_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Qux9clPeNCQx9tzyd3Y_v054KGg=" alt=""></p><h2 id="虚函数特性">虚函数特性</h2><p>所有虚函数都必须有定义。</p><p>当某个虚函数通过指针或引用调用时，对虚函数的调用在运行时才被解析。</p><h3 id="覆盖规则">覆盖规则</h3><p>如果要在派生类中覆盖继承来的虚函数，形参类型必须完全一致。</p><p>否则名字相同但参数列表不同的函数会成为独立的新函数，而不是覆盖原有的。</p><p>因为声明在内层作用域的函数并不会重载声明在外层作用域的函数，而是隐藏外层的。</p><h3 id="特殊说明符">特殊说明符</h3><ul><li>可以在派生类中使用override标记，此时如果没有覆盖原有的虚函数，编译器会报错</li><li>单独将函数指定为final，之后任何尝试覆盖该函数的操作都会报错</li></ul><h3 id="其他注意事项">其他注意事项</h3><ul><li>虚函数总是使用基类中定义的默认实参</li><li>可以使用作用域运算符规避虚函数的动态绑定<br><img src="https://cdn-a.markji.com/files/67eb4e06205d5713c0cf9775_hd.png?e=1745422494155&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:N9gNCJ2GaOGWb7oPsrg_e7l4VVE=" alt=""></li></ul>]]></content>
    
    
    <summary type="html">C++中的类型转换、继承关系以及虚函数的详细解析</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Qt非阻塞延迟实现</title>
    <link href="https://www.magicat.cc/posts/qt-non-blocking-delay.html"/>
    <id>https://www.magicat.cc/posts/qt-non-blocking-delay.html</id>
    <published>2025-04-15T15:23:37.000Z</published>
    <updated>2025-04-15T15:23:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QTimer-singleShot简介"><a href="#QTimer-singleShot简介" class="headerlink" title="QTimer::singleShot简介"></a>QTimer::singleShot简介</h2><p><img src="https://cdn-a.markji.com/files/68076cb12d05657363373ede_hd.png?e=1745509985100&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:iFm9_QupELxQqTeUfrVVlBBltxQ=" alt=""></p><h2 id="QEventLoop简介"><a href="#QEventLoop简介" class="headerlink" title="QEventLoop简介"></a>QEventLoop简介</h2><p>QEventLoop 是控制事件循环的类，它在 Qt 程序中管理事件队列，并将事件分发到相应的对象。</p><h2 id="事件循环控制"><a href="#事件循环控制" class="headerlink" title="事件循环控制"></a>事件循环控制</h2><p>exec()函数启动事件循环，等待事件的发生。直到调用 quit() 方法或事件循环结束，程序才会继续执行后面的代码。</p><p>等待的过程是非阻塞的，可以在等待过程中响应其他事件。</p><p>quit() 用于退出事件循环。<br><img src="https://cdn-a.markji.com/files/680775f56092fd692c29d001_hd.png?e=1745509985100&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:mq7ppAE5sdGRE2hcmUV0Qew__TU=" alt=""></p>]]></content>
    
    
    <summary type="html">Qt中使用QEventLoop实现非阻塞延迟的方法详解</summary>
    
    
    
    <category term="GUI开发" scheme="https://www.magicat.cc/categories/GUI%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="Qt" scheme="https://www.magicat.cc/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt对象树机制</title>
    <link href="https://www.magicat.cc/posts/qt-object-tree.html"/>
    <id>https://www.magicat.cc/posts/qt-object-tree.html</id>
    <published>2025-04-15T15:21:43.000Z</published>
    <updated>2025-04-15T15:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Qt对象继承体系"><a href="#Qt对象继承体系" class="headerlink" title="Qt对象继承体系"></a>Qt对象继承体系</h2><p>QObject是大多数对象的基类，QWidget继承于QObject，又是大多数页面和窗口组件的基类。</p><h2 id="对象树结构"><a href="#对象树结构" class="headerlink" title="对象树结构"></a>对象树结构</h2><p>当QOject及其子类之间建立父子关系时，所有子类对象会被加入父类对象一个成员变量名为children的列表中。</p><p>当父对象析构时，children里的所有子对象也会一起析构；如果子对象先被析构，会自动被父对象的children列表移除。<br><img src="https://cdn-a.markji.com/files/67fa2e507f917e87d7c3bff6_hd.png?e=1745509985100&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:7tDj9yoaV3bsuvNjJO3b6ZICfqE=" alt=""></p><h2 id="父对象设置"><a href="#父对象设置" class="headerlink" title="父对象设置"></a>父对象设置</h2><p>所以一般在创建qt子对象时，会先在构造函数初始化列表就指定parent对象。</p><p>默认写法可以是ReadThread(QObject *parent = nullptr)，父对象为空。</p>]]></content>
    
    
    <summary type="html">Qt框架中的对象树结构及其内存管理机制详解</summary>
    
    
    
    <category term="GUI开发" scheme="https://www.magicat.cc/categories/GUI%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="Qt" scheme="https://www.magicat.cc/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>视频软解码流程3 close函数</title>
    <link href="https://www.magicat.cc/posts/video-resource-cleanup.html"/>
    <id>https://www.magicat.cc/posts/video-resource-cleanup.html</id>
    <published>2025-04-14T15:16:11.000Z</published>
    <updated>2026-02-24T15:16:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="close函数实现"><a href="#close函数实现" class="headerlink" title="close函数实现"></a>close函数实现</h2><h3 id="1-清空缓存"><a href="#1-清空缓存" class="headerlink" title="1. 清空缓存"></a>1. 清空缓存</h3><p>定义了clear工具函数，要用到两个api：</p><ul><li>avformat_flush传入解封装上下文，刷新解封装上下文的高层读取缓冲区</li><li>avio_flush传入解封装上下文中的pb指针，刷新pb指向的低层io缓冲区<br><img src="https://cdn-a.markji.com/files/67fa253f75151df2bbaeece9_hd.png?e=1745509985100&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:-EYQzh0e8Co_xsijeoaT3CA1P6c=" alt=""></li></ul><h3 id="2-释放内存"><a href="#2-释放内存" class="headerlink" title="2. 释放内存"></a>2. 释放内存</h3><p>定义free工具函数释放ffmpeg对象的内存，再释放普通成员变量的内存。</p><h2 id="其他工具函数"><a href="#其他工具函数" class="headerlink" title="其他工具函数"></a>其他工具函数</h2><p>还有两个辅助工具函数：</p><ul><li>isEnd：返回视频是否读取完成</li><li>pts：返回当前帧的显示时间</li></ul>]]></content>
    
    
    <summary type="html">视频资源释放与缓存清理</summary>
    
    
    
    <category term="多媒体技术" scheme="https://www.magicat.cc/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="音视频开发" scheme="https://www.magicat.cc/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    <category term="FFmpeg" scheme="https://www.magicat.cc/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>视频软解码流程2 read函数</title>
    <link href="https://www.magicat.cc/posts/video-decoding-image-conversion.html"/>
    <id>https://www.magicat.cc/posts/video-decoding-image-conversion.html</id>
    <published>2025-04-12T06:43:01.000Z</published>
    <updated>2025-04-12T06:48:06.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频解码流程"><a href="#视频解码流程" class="headerlink" title="视频解码流程"></a>视频解码流程</h2><p>read函数，返回Qimage<br>完成解码：原始数据包-&gt;发送给解码器上下文-&gt;解码后视频帧<br>首先从解封装上下文读取原始数据帧进packet数据包<br>把数据包发送给解码器上下文有两种情况，<br>一种是读取已完成发空数据包，一种是正常传原始数据包<br>如果不是空包，就涉及将pts和dts由时间戳转换为毫秒单位，再发送给解码器<br><img src="https://cdn-a.markji.com/files/67f8c678eb27578088b65e94_hd.png?e=1744442663818&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Taa51o3pQhJ6ZMe-WoYo-TZNn9c=" alt=""></p><h2 id="图像格式转换"><a href="#图像格式转换" class="headerlink" title="图像格式转换"></a>图像格式转换</h2><p>图像转换上下文-&gt;进行转换-&gt;最后转成QImage<br>必须在解码后才能初始化图像转换上下文，硬解码时图像格式会发生改变，因此只有解码后才能安全进行图像转换<br>初始化的api需要传入图像输入输出的分辨率、缩放算法（比如YUV和RGB）、滤波器信息（可以null），返回初始化后的图像转换上下文<br>api的逻辑是获取缓存的图像转换上下文。首先校验上述参数是否一致，如果校验不通过就释放资源；然后判断上下文是否存在，如果存在直接复用，如不存在进行分配、初始化操作。<br>这里得到YUV到RGB的图像格式转换上下文，将转换好的图像格式存入_swsContext图像转换上下文<br><img src="https://cdn-a.markji.com/files/67f8cf93eb27578088b7ff1c_hd.png?e=1744442663818&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:GEULwilbn1spi7mHPJKWc8MUk-E=" alt=""></p><h2 id="图像平面与步幅"><a href="#图像平面与步幅" class="headerlink" title="图像平面与步幅"></a>图像平面与步幅</h2><p>然后利用这个上下文进行图像转换，需要输入输出存放每个平面指针的data数组，存放每平面步幅的lines数组，额外输入第几行开始处理，总共处理多少行<br>图像平面指的是图像中某一个颜色通道的所有像素数据组成的二维区域，每个颜色通道的数据单独存储在一块连续的内存中，这块内存就叫做一个”平面”。<br>RGB所有颜色连续存储，只有一个平面；YUV 图像的 Y、U、V 分量是分开存储的，分别在不同的内存区域，有Y、U、V三个平面<br>步幅就是每平面每行的字节数，每个图像平面中，一行像素数据实际占用的内存字节数<br><img src="https://cdn-a.markji.com/files/67f8d22deb27578088b86bd2_hd.png?e=1744442663818&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:QTtAl-ft4t4D4lsiNmZDLx1MOP4=" alt=""><br><img src="https://cdn-a.markji.com/files/67f8d255eb27578088b86f7d_hd.png?e=1744442663818&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:bOtyow_hAbdSLOhA9VDDMNmKtiQ=" alt=""></p><h2 id="转换为Qt图像"><a href="#转换为Qt图像" class="headerlink" title="转换为Qt图像"></a>转换为Qt图像</h2><p>图像转换完成后m_frame解码后的视频帧里存的就是rgb格式<br>可以直接转化成QImage格式</p>]]></content>
    
    
    <summary type="html">视频解码过程及图像格式转换实现</summary>
    
    
    
    <category term="多媒体技术" scheme="https://www.magicat.cc/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="音视频开发" scheme="https://www.magicat.cc/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    <category term="FFmpeg" scheme="https://www.magicat.cc/tags/FFmpeg/"/>
    
    <category term="Qt" scheme="https://www.magicat.cc/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>视频软解码流程1 open函数</title>
    <link href="https://www.magicat.cc/posts/video-decoding-process.html"/>
    <id>https://www.magicat.cc/posts/video-decoding-process.html</id>
    <published>2025-04-10T15:24:24.000Z</published>
    <updated>2025-04-12T06:48:28.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频文件打开流程"><a href="#视频文件打开流程" class="headerlink" title="视频文件打开流程"></a>视频文件打开流程</h2><p>先丢一个流程图<br><img src="https://cdn-a.markji.com/files/67f78cddeb2757808894e0e1_hd.png?e=1744301131161&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:s0q3evngz3sBOf5b2kXXODt_qq8=" alt=""></p><p>open函数，需要传入url，返回bool是否成功打开</p><p>在打开输入流之前先定义了参数字典，通过这个字典和传入的url打开输入流<br><img src="https://cdn-a.markji.com/files/67f78e1fc7682418c3f4421b_hd.png?e=1744301131161&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Dt1o-dsDVm9-XdUPUEw6a4Q9iyw=" alt=""></p><h2 id="解封装过程"><a href="#解封装过程" class="headerlink" title="解封装过程"></a>解封装过程</h2><h3 id="解封装上下文-gt-视频流"><a href="#解封装上下文-gt-视频流" class="headerlink" title="解封装上下文-&gt;视频流"></a>解封装上下文-&gt;视频流</h3><p>打开输入流，返回解封装上下文</p><p>通过解封装上下文读取媒体信息，顺带得到视频总时长</p><p>再通过解封装上下文和AVMEDIA_TYPE_VIDEO枚举视频流ID</p><p>就能在解封装上下文中根据视频流ID获取视频流</p><h2 id="解码过程"><a href="#解码过程" class="headerlink" title="解码过程"></a>解码过程</h2><h3 id="视频流-gt-解码器-gt-解码器上下文-gt-打开解码器"><a href="#视频流-gt-解码器-gt-解码器上下文-gt-打开解码器" class="headerlink" title="视频流-&gt;解码器-&gt;解码器上下文-&gt;打开解码器"></a>视频流-&gt;解码器-&gt;解码器上下文-&gt;打开解码器</h3><p>videoStream-&gt;codecpar 是一个 AVCodecParameters*，它保存了解封装后提取出的流的编解码参数，是解封装阶段从媒体中提取出来的参数集合</p><p>AVFormatContext（解封装）和 AVCodecContext（解码）是两个阶段，前面只是解封装了，但并没有解码</p><p>通过视频流里的codecpar参数集合找到视频分辨率（长和宽）和总帧率，</p><p>直接从视频流获取视频帧率，但涉及分数（AVRational）到小数（qreal）的转换<br><img src="https://cdn-a.markji.com/files/67f79832c7682418c3f5dd50_hd.png?e=1744301131161&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ut8gL7ppfd-jSR-kFM4yeGCMT2w=" alt=""></p><h2 id="解码器配置"><a href="#解码器配置" class="headerlink" title="解码器配置"></a>解码器配置</h2><p>再通过视频流里的codecpar参数集合中的codec-&gt;id 解码器ID获取视频解码器</p><p>通过解码器获取解码器上下文</p><p>然后使用视频流的codecpar为解码器上下文赋值，再使用赋值后的解码器上下文打开解码器</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>最后提前分配AVPacket数据包和AVFrame解码后的视频帧的空间</p><p>根据之前得到的图像分辨率，计算图像所需内存大小，然后按计算得到的大小分配图像数据空间</p>]]></content>
    
    
    <summary type="html">视频文件的打开、解封装和解码流程</summary>
    
    
    
    <category term="多媒体技术" scheme="https://www.magicat.cc/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="音视频开发" scheme="https://www.magicat.cc/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    <category term="FFmpeg" scheme="https://www.magicat.cc/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>类型转换与继承</title>
    <link href="https://www.magicat.cc/posts/type-conversion-inheritance.html"/>
    <id>https://www.magicat.cc/posts/type-conversion-inheritance.html</id>
    <published>2025-04-01T15:26:37.000Z</published>
    <updated>2025-04-01T15:26:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基类与派生类的类型转换">基类与派生类的类型转换</h2><p>可以将基类指针/引用绑定到派生类对象上。也就是可以把派生类对象当成基类对象使用（需要传基类对象的参数也可以传派生类对象），但不能将基类转换成派生类。</p><h2 id="静态类型与动态类型">静态类型与动态类型</h2><ul><li><strong>静态类型</strong>：变量或表达式在编译时确定的类型，由声明决定。代码写下时，编译器就能知道其静态类型。</li><li><strong>动态类型</strong>：变量或表达式在运行时所表示的对象的实际类型。只有当程序运行时，才知道变量指向的具体对象是什么。</li></ul><p>基类指针或引用可以指向派生类对象，此时，静态类型仍然是基类类型，动态类型则是运行时绑定的派生类类型。即该指针或引用只能访问基类的成员，其中非虚函数调用的是基类的版本，虚函数会动态绑定到派生类定义的版本。<br><img src="https://cdn-a.markji.com/files/67eb4702205d5713c0ce74ea_hd.png?e=1743524964854&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:vwFkjPk-l3HiRHflk6XZOw57uME=" alt=""></p><h2 id="对象赋值的特殊情况">对象赋值的特殊情况</h2><p>如果是直接将派生类对象赋值给基类，仅保留基类部分，派生类的成员被丢弃。之后，该对象的动态类型就变成了基类。<br><img src="https://cdn-a.markji.com/files/67eb464d205d5713c0ce5701_hd.png?e=1743524964854&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ohIN6Rl1fDacWGV75YvGo6dYIZI=" alt=""></p>]]></content>
    
    
    <summary type="html">C++中类型转换与继承的关系及静态类型与动态类型的区别</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>POSIX网络协议栈</title>
    <link href="https://www.magicat.cc/posts/posix-socket.html"/>
    <id>https://www.magicat.cc/posts/posix-socket.html</id>
    <published>2025-03-28T02:26:37.000Z</published>
    <updated>2025-04-24T15:19:09.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器端流程"><a href="#服务器端流程" class="headerlink" title="服务器端流程"></a>服务器端流程</h2><ol><li><p><strong>创建socket</strong>：选择UDP或TCP协议，返回一个整型句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// TCP</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);  <span class="comment">// UDP</span></span><br></pre></td></tr></table></figure></li><li><p><strong>绑定socket</strong>：将socket绑定到特定IP地址和端口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// 任意IP</span></span><br><span class="line">server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br></pre></td></tr></table></figure></li><li><p><strong>监听socket</strong>：监听绑定的端口（仅TCP需要）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(sockfd, BACKLOG); <span class="comment">// BACKLOG为等待连接队列的最大长度</span></span><br></pre></td></tr></table></figure></li><li><p><strong>接受连接</strong>：接受客户端连接请求（仅TCP需要）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"><span class="type">int</span> client_sockfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br></pre></td></tr></table></figure></li><li><p><strong>发送数据</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP</span></span><br><span class="line">send(client_sockfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UDP</span></span><br><span class="line">sendto(sockfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>, </span><br><span class="line">       (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, <span class="keyword">sizeof</span>(client_addr));</span><br></pre></td></tr></table></figure></li><li><p><strong>接收数据</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP</span></span><br><span class="line">recv(client_sockfd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UDP</span></span><br><span class="line">recvfrom(sockfd, buffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">         (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br></pre></td></tr></table></figure></li><li><p><strong>关闭连接</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(client_sockfd); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">close(sockfd);        <span class="comment">// 关闭服务器socket</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="客户端流程"><a href="#客户端流程" class="headerlink" title="客户端流程"></a>客户端流程</h2><ol><li><p><strong>创建socket</strong>：与服务器端相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// TCP</span></span><br></pre></td></tr></table></figure></li><li><p><strong>发起连接</strong>：连接到服务器（仅TCP需要）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">// 服务器IP</span></span><br><span class="line">server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br></pre></td></tr></table></figure></li><li><p><strong>发送/接收数据</strong>：与服务器端相同</p></li><li><p><strong>关闭连接</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(sockfd);</span><br></pre></td></tr></table></figure><p>```</p></li></ol>]]></content>
    
    
    <summary type="html">POSIX网络协议栈中服务器和客户端的基本操作流程</summary>
    
    
    
    <category term="计算机网络" scheme="https://www.magicat.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络编程" scheme="https://www.magicat.cc/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Socket" scheme="https://www.magicat.cc/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>类类型转换</title>
    <link href="https://www.magicat.cc/posts/class-type-conversion.html"/>
    <id>https://www.magicat.cc/posts/class-type-conversion.html</id>
    <published>2025-03-25T15:31:34.000Z</published>
    <updated>2025-03-25T15:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类类型转换运算符"><a href="#类类型转换运算符" class="headerlink" title="类类型转换运算符"></a>类类型转换运算符</h2><p>类类型转换运算符是类的特殊成员函数，将一个类对象的值转换为其他类型。</p><p>没有显式的返回类型也没有形参，一般是const，真正的返回类型由函数名决定。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>有两个转换路径，构造函数和类类型转换运算符。<br><img src="https://cdn-a.markji.com/files/67e206912acfe6cc5a34c8b6_hd.png?e=1745511168403&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:OacYINZ9WNWp8ehp8yupz1N59Ns=" alt=""><br><img src="https://cdn-a.markji.com/files/67e206a105df2632082523cb_hd.png?e=1745511168403&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:UXteuL4T4eef4dNzEoNcIqSiOcA=" alt=""></p><h2 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h2><p>前面加上explicit，除了用作条件，只能显式调用。<br><img src="https://cdn-a.markji.com/files/67e207c905df26320825582d_hd.png?e=1745511168403&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MXgNBmy11wAagDqN3-HK9_pGdWM=" alt=""><br><img src="https://cdn-a.markji.com/files/67e207f081bdefd1bebbf7a3_hd.png?e=1745511168403&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:BpnbzrjJ-tYOgcjaSAroSKRrRBg=" alt=""></p><h2 id="避免二义性转换"><a href="#避免二义性转换" class="headerlink" title="避免二义性转换"></a>避免二义性转换</h2><p>当类中包含类型转换时，必须确保在类类型和目标类型之间只有唯一的转换方式，否则编译器会不知道该选择哪个转换，导致二义性错误。</p><h3 id="二义性的两种情况"><a href="#二义性的两种情况" class="headerlink" title="二义性的两种情况"></a>二义性的两种情况</h3><ol><li><p>两个类之间存在相同的类型转换<br><img src="https://cdn-a.markji.com/files/67e20fe681bdefd1bebd0179_hd.png?e=1745511168403&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:zNseuxsCkSF_AimlGlh5MRzb5hE=" alt=""></p></li><li><p>类定义了多个与算术类型相关的转换</p></li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>尽量只提供一个用户定义的类型转换（如operator int() 或 operator double() 选一个）</li><li>避免多个接受不同算术类型的构造函数（最好只提供 A(double)，避免 A(int) + A(double) 并存）</li><li>显式调用转换，避免隐式转换带来的二义性问题</li></ul>]]></content>
    
    
    <summary type="html">C++中类类型转换的机制及二义性问题的处理</summary>
    
    
    
    <category term="编程语言" scheme="https://www.magicat.cc/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://www.magicat.cc/tags/C/"/>
    
    <category term="面向对象" scheme="https://www.magicat.cc/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
